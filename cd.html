<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="media/linuxpenguin.png" type="image/x-icon">
  <meta charset="UTF-8">
  <title>[demo 22726]</title>
  <style>
    body, html {
      height: 100%;
      margin: 0;
      background: black;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    #cdModelContainer { width: 100vw; height: 100vh; }
    #cdInteractionButton {
      position: absolute;
      width: 40vw;
      height: 30vw;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0);
      border: none;
      cursor: pointer;
      display: block;
      z-index: 10;
    }
  </style>
</head>

<body>
  <div id="cdModelContainer">
    <button id="cdInteractionButton"></button>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- IMPORTANT: versioned DRACO loader + decoder path -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/DRACOLoader.js"></script>

  <script>
    console.log("Script is running");

    // ---------- helpers ----------
    function disposeObject3D(obj) {
      if (!obj) return;
      obj.traverse((child) => {
        if (child.isMesh) {
          if (child.geometry) child.geometry.dispose();
          const mat = child.material;
          const disposeMat = (m) => {
            if (!m) return;
            for (const key in m) {
              const val = m[key];
              if (val && val.isTexture) val.dispose();
            }
            m.dispose();
          };
          if (Array.isArray(mat)) mat.forEach(disposeMat);
          else disposeMat(mat);
        }
      });
    }

    // ---------- scene setup ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('cdModelContainer').appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040, 4));
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // Loader (GLTF + DRACO)
    const loader = new THREE.GLTFLoader();
    const dracoLoader = new THREE.DRACOLoader();
    dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/libs/draco/');
    loader.setDRACOLoader(dracoLoader);

    let cdMesh = null;

    // Songs
    const songs = [
      { song: 'audio/bloodgnats.mp3', model: 'media/CD2.glb' },
      { song: 'audio/walkdown.mp3', model: 'media/CD2.glb' },
      { song: 'audio/orochimaru.mp3', model: 'media/CD2.glb' },
      { song: 'audio/the rapture.mp3', model: 'media/CD2.glb' },
      { song: 'audio/Trapstar.mp3', model: 'media/CDgreen.glb' },
      { song: 'audio/I_Know.mp3', model: 'media/CDgreen.glb' },
      { song: 'audio/GOBLINREAL.mp3', model: 'media/CDgreen.glb' },
      { song: 'audio/foresight.mp3', model: 'media/CDred.glb' },
      { song: 'audio/tranquility.mp3', model: 'media/CDred.glb' },
      { song: 'audio/quasar.mp3', model: 'media/CDred.glb' }
    ];

    const audio = new Audio();

    // Rotation state
    let targetXRotation = Math.PI / 3;
    let targetYRotation = (Math.PI / 5) * (-3.75);
    let targetZRotation = 0;

    const spinSpeed = 0.015;
    const clickSpinSpeed = 0.4;
    let currentSpinSpeed = spinSpeed;

    let isClicked = false;
    let isTransitionComplete = false;

    // ---------- model load ----------
    function loadModel(path, onDone) {
      console.log("Loading model:", path);

      loader.load(
        path,
        (gltf) => {
          // dispose old model (mobile fix)
          if (cdMesh) {
            scene.remove(cdMesh);
            disposeObject3D(cdMesh);
          }

          cdMesh = gltf.scene;
          scene.add(cdMesh);

          cdMesh.scale.set(15, 15, 15);
          cdMesh.rotation.x = targetXRotation;
          cdMesh.rotation.y = targetYRotation;
          cdMesh.rotation.z = targetZRotation;

          console.log("Model loaded OK:", path);
          if (onDone) onDone();
        },
        (xhr) => {
          // xhr.total can be 0 sometimes (no length header), so guard
          if (xhr.total) {
            console.log(`${path} ${(xhr.loaded / xhr.total * 100).toFixed(1)}%`);
          }
        },
        (err) => {
          console.error("MODEL LOAD FAILED:", path, err);
        }
      );
    }

    // initial model
    camera.position.z = 50;
    loadModel('media/CD2.glb', () => {
      animate();
    });

    // ---------- play random ----------
    function playRandomSong() {
      const index = Math.floor(Math.random() * songs.length);
      const selected = songs[index];

      console.log("Selected:", selected.song, "Model:", selected.model);

      // load model for this song
      loadModel(selected.model);

      // play audio
      audio.src = selected.song;
      audio.play().catch((e) => {
        console.warn("Audio play blocked until user gesture (normal on mobile).", e);
      });
    }

    // ---------- animation ----------
    function animate() {
      requestAnimationFrame(animate);

      if (!cdMesh) {
        renderer.render(scene, camera);
        return;
      }

      if (isClicked) {
        if (!isTransitionComplete) {
          const dx = (targetXRotation - cdMesh.rotation.x) * 0.1;
          const dy = (targetYRotation - cdMesh.rotation.y) * 0.1;
          const dz = (targetZRotation - cdMesh.rotation.z) * 0.1;

          cdMesh.rotation.x += dx;
          cdMesh.rotation.y += dy;
          cdMesh.rotation.z += dz;

          if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01 && Math.abs(dz) < 0.01) {
            isTransitionComplete = true;
            currentSpinSpeed = clickSpinSpeed;
          }
        } else {
          cdMesh.rotation.y += currentSpinSpeed;
          cdMesh.rotation.z = 0;
        }
      } else {
        cdMesh.rotation.z += currentSpinSpeed;
        isTransitionComplete = false;
      }

      renderer.render(scene, camera);
    }

    // ---------- click ----------
    document.getElementById('cdInteractionButton').addEventListener('click', () => {
      toggleCDPlay();
    });

    function toggleCDPlay() {
      isClicked = !isClicked;

      if (isClicked) {
        targetXRotation = 0.35;
        targetYRotation = (Math.PI / 5) * (-2.75);
        targetZRotation = 0;
        playRandomSong();
      } else {
        targetXRotation = Math.PI / 3;
        targetYRotation = (Math.PI / 5) * (-2.75);
        targetZRotation = 0;

        currentSpinSpeed = spinSpeed;
        audio.pause();
        audio.currentTime = 0;
      }
    }

    // ---------- resize ----------
    function adjustInteractionButton() {
      const interactionButton = document.getElementById('cdInteractionButton'); // FIXED
      const cdWidth = renderer.domElement.clientWidth * 0.30;
      const cdHeight = cdWidth;

      interactionButton.style.width = `${cdWidth}px`;
      interactionButton.style.height = `${cdHeight}px`;
      interactionButton.style.left = `calc(50% - ${cdWidth/2}px)`;
      interactionButton.style.top = `calc(50% - ${cdHeight/2}px)`;
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      adjustInteractionButton();
    });

    document.addEventListener('DOMContentLoaded', adjustInteractionButton);
    adjustInteractionButton();
  </script>
</body>
</html>
